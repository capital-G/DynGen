TITLE:: DynGen
summary:: Evaluates dynamic code on the server
categories:: UGens>Dynamic
related:: Classes/DynGenDef

DESCRIPTION::
This UGen evaluates LINK::https://www.cockos.com/EEL2/##EEL2:: (expression evaluation library/realtime compiler) code in a VM which runs on the server.
This allows to write DSP code on the fly and perform single sample operations.

The code has to be registered using LINK::Classes/DynGenDef:: and follows a similar approach to LINK::Classes/SynthDef:: by registering a resource (code) under a given name.
This also allows to update the evaluated code on the fly.

Each script can expose multiple outputs and the output for each channel can be written to via the variable CODE::out0::, CODE::out1::, ...
When the script gets evaluated through DynGen it is also necessary to tell how many outputs of the script should be exposed.

CODE::
// the server needs to be booted b/c we need to register the code on the server through DynGenDef
s.boot;

DynGenDef(\example, "out0 = 0.5;").send;

(
Ndef(\x, {
	DynGen.ar(
		1, // number of outputs
		\example, // DynGen reference to use - can be a symbol or a DynGen instance
	).poll;
});
)
::

NOTE::
The first polled value of this example yields MATH::0.0:: instead of MATH::0.5::.
This is because the initialization of the VM and the compilation of the script is defered to a non-realtime thread in order not to cause audio dropouts in case this process takes too long.
If you want to run these steps on the realtime audio thread and want to get rid of this delay you can set the parameter CODE::realtime:: to 1.0, but be beware of potential dropouts on bigger scripts.
::

It is also possible to update the associated code while the synth is running by replacing it through the associated code::DynGenDef:: definition.

CODE::
DynGenDef(\example, "out0 = 0.1;").send;

// now 0.1 should be polled

Ndef(\x).clear;
::

It is also possible to process external input in a script by using the variables CODE::in0::, CODE::IN1::, ... and provide input signals at the invocation of the UGen.

CODE::
DynGenDef(\myInput, "out0 = in0 * 0.1;").send;

(
Ndef(\x, {
	DynGen.ar(
		1, // number of output channels of our script
		DynGenDef(\myInput), // reference to the script to use - here by using a DynGenDef object instead of a symbol
		SinOsc.ar(0.5), // will be made available as in0 within the script
	).poll;
}).play;
)

Ndef(\x).clear;
::

The examples here use LINK::Classes/Ndef:: of JITLib for the ease of iterative development, but it is also possible to use LINK::Classes/SynthDef:: and LINK::Classes/Synth::

CODE::
DynGenDef(\synth, "out0 = in0 * 0.2;").send;

(
SynthDef(\dynGen, {|out|
	var sig = DynGen.ar(
		numOutputs: 1,
		script: \synth,
		inputs: SinOsc.ar(200.0),
	);
	Out.ar(out, sig);
}).add;
)

x = Synth(\dynGen);
x.free;
::

or also plain functions using LINK::Classes/Function#-play::, here with declaring the LINK::Classes/DynGenDef:: script EMPHASIS::inline::.

CODE::
(
x = {DynGen.ar(
	numOutputs: 1,
	script: DynGenDef(\fun, "out0 = in0 * 0.2;").send,
	inputs: SinOsc.ar(200.0),
)}.play;
)

x.free;
::

NOTE::
EEL2 works internally with 64 bit floats (also called doubles) instead of SuperColliders 32 bit floats - it therefore can be useful to use DynGen for really slow processes (e.g. a line which goes from 0.0 to 1.0 in 60 minutes) or where high precission is desirable (e.g. when using phase interpolations).
Since SuperCollider only can work on 32 bit floats on the server side the precission of the floats have to be reduced when outputting them to SuperCollider.
::

SUBSECTION:: Parameters

It is not just possible to use the pre-defined variables within a script but also declare new ones which allows us to store past values for performing single sample based calulations.
Instead of passing parameters as input, we can declare them in the script with a pre-pended CODE::_::, which we then can refer to without the pre-fixed name as a keyword argument within DynGen which makes the code clearer.

CODE::
(
DynGenDef(\fbSin, "
// make variables persistent across invocations
phase += 0;
y1 += 0;

omega = phase + (_feedback * y1);

// phase increment of normal sin osc
phase +=  2*$pi * _freq / srate;

// exercise: wrap phase between [0, 2pi)

// output
out0 = sin(omega);

// store previous output for next sample
y1 = out0;
").send;
)
::

CODE::
(
Ndef(\z, {
	DynGen.ar(1, \fbSin,
		params: [
			freq: \freq.ar(200.0),
			feedback: \feedback.ar(0.0, spec: [0.0, 2.0]),
		]
	) ! 2 * \amp.kr(0.2);
}).play.gui;
)
::

SUBSECTION:: Multi-channel expansion

NOTE::
Multi-channel expansion is still a field of discussion.
If you have suggestions or feedback, please get in contact via the forum or the repository.
::

To clarify if a signal should be perceived as n-dimensional input or it should create n-paralell processes of DynGen, every signal that is EMPHASIS::flat:: will be passed as input to DynGen and every nested signal will create parallel instances of DynGen, where normal multi-channel expansion semantics are applied.

If CODE::inputs:: is a EMPHASIS::flat:: signal, the whole signal will be passed to a single DynGen instance.

CODE::
(
Ndef(\multiX, {
	var sig = SinOsc.ar([200, 800]);
	DynGen.ar(1, DynGenDef(\multi, "out0 = in0").send,
		inputs: sig.postln,
	).postln * 0.1;
}).play;
)
::

If CODE::inputs:: is nested via an array, it will create paralell DynGen instances according to the traditional multi-channel expansion.

CODE::
(
Ndef(\multiY, {
	var sig = SinOsc.ar([200, 800]);
	DynGen.ar(1, DynGenDef(\multi, "out0 = in0").send,
		inputs: [sig].postln,
	).postln * 0.1;
}).play;
)
::

Since parameters are only available as one-dimensional scalars within DynGen code, any multi-channel parameters will result in multi-channel expanded DynGen instances.

CODE::
(
Ndef(\multiParam, {
	var sig = SinOsc.ar([200, 800]);
	DynGen.ar(1, DynGenDef(\multiParam, "out0 = in0 * _amp").send,
		inputs: sig,
		params: [
			\amp: LFPulse.kr([3.0, 1.0]),
		],
	).postln * 0.1;
}).play;
)
::

Instead of passing parameter via keyword arguments to DynGen, it is also possible to pass an array of parameters which allows more control over multi-channel expansion.

CODE::
(
Ndef(\multiParamArr, {
	var sig = SinOsc.ar([200, 800]);
	sig = DynGen.ar(2, DynGenDef(\multiParamArr, "out0 = in0 * _amp0; out1 = in1 * _amp1").send,
		inputs: sig,
		params: [
			// params for first instance
			[amp0: SinOsc.kr(0.3)],
			// params for second instance
			[amp1: SinOsc.kr(0.5)],
		].flop,  // manually flop!
	);
	// fold down 2x2 to 1x2 using sum
	sig.sum * 0.2;
}).play;
)
::

SUBSECTION:: Memory

Each DynGen instance has access to STRONG::one:: consecutive block of memory.
This memory can be accessed through square brackets, where the value left to the square brackets add an offset to the memory address.

An example illustrates this unique feature, which is contrary to how arrays work in sclang!

CODE::
// writes value 20.0 to location 0!
buf[0] = 20.0;
// reads memory of location 0, which has value 20.0!
out0 = buf2[0];
::

Since CODE::buf:: and CODE::buf2:: were never declared, they default to CODE::0.0::.
CODE::buf[0]:: therefore references the memory address CODE::0:: since CODE::buf:: has a value of CODE::0.0:: and has an offset CODE::[0]:: of CODE::0::.
Similar, CODE::buf2[0]:: references the STRONG::same:: address, since it also refers to the address CODE::0.0:: of CODE::buf2:: (since it was never initialized) with an offset of CODE::0::, which results in the same memory address of CODE::0::.

The value of the variable therefore only acts as an offset to the memory block of the DynGen instance!
Therefore do not do the following

CODE::
// DO NOT DO THIS
bufA[in0] = in1;
bufB[in2] = in2;
::

but instead do the following

CODE::
bufA = 0;
// create an offset of 1024 for bufB
// bufA therefore uses the range from 0-1023
// and bufB from 1024-2047 (or beyond)
bufB = 1024;

// bufA + (in0%1024) = 0 + (in0%1024)
bufA[in0%1024] = in1;
// bufB + (in2%1024) = 1024 + (in2%1024)
bufB[in2%1024] = in2;
// note that % only operates on integers in DynGen!
::

An example where this setup is necessary is shown in the FFT section.

Here is an example of a small granular delay.
Grain delays normally use an amplitude envelope for each grain, which is omitted here, and therefore results in a clicky sound.


CODE::
(
DynGenDef(\granular, "
grainIndex += 1;

// sample random offset when grain finished
readOffset += (grainIndex >= _grainSize) * rand() * _bufferSize;
// wrap offset
readOffset -= (readOffset >= _bufferSize) * _bufferSize;

// wrap grainIndex
grainIndex -= (grainIndex >= _grainSize) * _grainSize;

writeIndex += 1;
writeIndex -= (writeIndex >= _bufferSize) * _bufferSize;

buffer[writeIndex] = in0;

readPos = readOffset + grainIndex;
readPos -= (readPos >= _bufferSize) * _bufferSize;

rightReadPos = readPos + _stereoOffset;
rightReadPos -= (rightReadPos >= _bufferSize) * _bufferSize;

out0 = buf[readPos];
out1 = buf[rightReadPos];
").send;
)
::

CODE::
(
Ndef(\g, {
	var sig = SinOscFB.ar(100, 1.3) * Env.perc(0.01, 0.2).ar(gate: Impulse.ar(4.0));
	var delay = DynGen.ar(2, \granular,
		sig,
		params: [
			bufferSize: 20000.0,
			grainSize: SinOsc.ar(1/pi).range(1000, 10000),
			stereoOffset: SinOsc.ar(0.05).range(0, 100),
		],
	);
	SelectX.ar(\wet.kr(0.5, spec: [0, 1.0]), [sig, delay]) * \amp.kr(0.2);
}).play;
)
::

SUBSECTION:: Oversampling

It is also possible to use for loops to perform oversampling.
Here is a code snippet which demonstrates this for an oscillator which syncs/resets a 2nd oscillator if the first oscillator is.
Since this needs to be timed precisely since otherwise phase accumulation errors occur, it is necessary to increase the resolution during syncing, which is exactly what oversampling is doing.

CODE::
(
DynGenDef(\oversample, "
oversample = 8;

osRate = srate * oversample;

phaseA += 0;
phaseB += 0;

incA = _freqA / osRate;
incB = _freqB / osRate;

loop(oversample,
  phaseA += incA;
  phaseB += incB;

  // reset B if a is wrapping
  phaseB *= 1 - (phaseA >= 1.0);

  phaseA -= 1 * (phaseA >= 1.0);
  phaseB -= 1 * (phaseB >= 1.0);
);

out0 = phaseA;
out1 = phaseB;
").send;
)
::

CODE::
(
Ndef(\oversample, {
	DynGen.ar(2, \oversample,
		params: [
			freqA: \freqA.kr(55.0),
			freqB: \freqB.kr(pi*1000.0),
		],
	) * 0.2;
}).play.gui;
)
::

SUBSECTION:: DynGen methods

DynGen also offers some internal methods to interact with SuperCollider resources.
These do not implement any kind of interpolation.

TABLE::
## STRONG::function:: || STRONG::comment::
## in(numChannel) || reads the n-th input channel - index gets clamped
## out(numChannel) || writes to the n-th output channel - index gets clamped
## bufRead(bufNum, bufFrame, [bufChan]) || reads the frame of a LINK::Classes/Buffer:: on the server. If the buffer does not exist or bufFrame is out of bounds it will return 0.0. The bufChan parameter is optional and defaults to the 0-th channel. If bufChan is out of bounds, it will be mapped to the first channel.
## bufReadL(bufNum, bufFrame, [bufChan]) || Same as bufRead but uses linear interpolation.
## bufReadC(bufNum, bufFrame, [bufChan]) || Same as bufRead but uses cubic interpolation.
## bufWrite(bufNum, bufFrame, bufVal, [bufChan]) || writes a value at the given position into a LINK::Classes/Buffer:: on the server and returns the written sample. If the buffer does not exist or bufFrame is out of bounds it will not write to the buffer. The bufChan parameter is optional and defaults to the 0-th channel. If bufChan is out of bounds, it will be mapped to the first channel.
::

An example of buffer playback

CODE::
~buffer = Buffer.read(s, path: ExampleFiles.apollo11);

DynGenDef(\buffer, "out0 = bufReadC(_bufNum, _bufFrame)").send;

(
Ndef(\p, {
	DynGen.ar(1, \buffer, params: [
		bufNum: ~buffer.bufnum,
		bufFrame: Phasor.ar(rate: SinOscFB.ar(5.3, 1.3) + 1.0, end: ~buffer.numFrames),
	]).dup * 0.2;
}).play;
)
::

NOTE::
Since EEL2 internally works with doubles instead of SuperCollider internal floats it is possible to go beyond the 32 bit address restrictions of LINK::Classes/BufRd:: by working with an internal DynGen phase which uses 64 bit floats.
This allows to address MATH::2^{53}:: samples accurately, which translates to around 6000 years on 48 kHz instead of the 6 minutes of LINK::Classes/BufRd::.
::

SUBSECTION:: DynGen sections

If no section block is given, the whole script will be evaluated for each sample.
It is also possible to indicate a section of the script which only gets evaluated during the initaliziation of the script by prefxinig the section with CODE::@init::.
A section which is prefixed with CODE::@block:: gets evaluated each block, see LINK::Classes/ServerOptions#-blockSize:: (aka the rate that CODE::.kr:: is running at).
If any of those two sections is provided, it is necessary to also provide a header for the per-sample script via CODE::@sample::.

The blocks need to be in order CODE::@init::, CODE::@block::, CODE::@sample::, where each of these blocks is optional except sample.

CODE::
(
DynGenDef(\blocks, "
@init
x = $pi;

@block
y += 1;

@sample
z += 1;

out0 = x;
out1 = y;
out2 = z;
").send;
)
::

CODE::
Ndef(\b, {DynGen.ar(3, \blocks).poll});
::

SUBSECTION:: DynGen constants

DynGen provides some constants which are accessible like normal variables.
There is no const protection, so pay attention to not overwrite them.

TABLE::
## STRONG::variable name:: || STRONG::comment::
## srate || same as LINK::Classes/ServerOptions#-sampleRate::
## blockSize || same as LINK::Classes/ServerOptions#-blockSize::
::

SUBSECTION:: FFT

DynGen also allows to perform FFT operations on a buffer, similiar to PV UGens of SuperCollider.
Valid FFT window sizes are 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, or 32768.

There is also DCT available via CODE::mdct(start_index, size):: and CODE::imdct(start_index, size):: and also a way to convolve two buffers via CODE::convolve_c(dest,src,size)::, typically performed on FFT buffers.

For further information see https://www.cockos.com/EEL2/index.php#advanced

CODE::
(
DynGenDef(\fft, "
@init
fftSize = 512;
// input buffer is starting at memory position 0
inBuf = 0;
// create a buffer with a memory offset of the size
// of our input buffer. fft consists of real and complex/imaginary
// part, so we need two times the fft size since we are copying the
// the non-fft inBuf over to the fft outBuf to perform fft
// if we do not copy over the zero-ed complex part of inBuf,
// we will have a tainted outBuf when performing fft
outBuf = fftSize * 2;
writePos = 0;

@sample
// write into our input buffer
inBuf[writePos] = in0;
writePos += 1;
//offset = in1;
//spread = in2;

// if we have enough samples in our input buffer,
// perform a fft step
writePos >= fftSize ? (
  memcpy(outBuf, inBuf, fftSize*2);
  fft(outBuf, fftSize);
  // separate real and complex parts
  fft_permute(outBuf, fftSize);

  // shift around some real parts
  i = 0;
  loop(fftSize,
    outBuf[i] = outBuf[((i)+(_offset * (_spread)))%fftSize];
    i+=1;
  );

  // interleaving real/complex again
  fft_ipermute(outBuf, fftSize);
  // inverse fft on the out buffer
  ifft(outBuf, fftSize);
  // reset write header
  writePos = 0;
);

// scale output of fft with fftSize!
out0 = outBuf[writepos] / fftSize;
").send;
)
::

CODE::
~buffer = Buffer.read(s, ExampleFiles.apollo11);
(
Ndef(\fft, {
	DynGen.ar(1, \fft,
		PlayBuf.ar(1, ~buffer, \rate.kr(1.0), loop: 1.0),
		params: [
			offset: \offset.ar(0.0, spec: [-512, 512]),
			spread: \spread.ar(1.0, spec: ControlSpec(-4.0, 4.0, step: 1/8)),
		],
	).tanh * 0.5.dup;
}).play.gui;
)
::

CLASSMETHODS::

METHOD:: ar
argument:: numOutputs
The number of outputs which will be output by this UGen.
The value of each output can be defined by writing a value to the variables CODE::out0::, CODE::out1::, ...
In case the script does not write to a variable it will output MATH::0.0::.

argument:: script
The LINK::Classes/DynGenDef:: script which should be used.
This can either be a LINK::Classes/Symbol:: with the name of the referenced script or a DynGenDef object.

argument:: inputs
An array of input signals.
Each input will be made available within the scripts through the variables CODE::in0::, code::in1::, ...

argument:: params
There are two ways to pass parameters to DynGen - either passing them as keyword argument or passing them as an array via the CODE::params:: argument.
Passing an array has benefits in regards to multi-channel expansion, though passing them as keyword arguments may be more erognomic.
The content of both, the params array and kwargs, will be merged.

argument:: realtime
Normally DynGen instances are spawned outside the audio thread to avoid audio dropouts (0.0), yet this introduces also a delay of at least one block size until the instance produces output.
If sample-precise timing is required from the first sample on, one can activate the realtime mode (1.0) which compiles and creates the DynGen vm in the real-time thread, though this can introduce audio-dropouts.
NOTE::
Compare the following versions of the code

CODE::
DynGenDef(\test, "out0 = 0.5").send;
::

Non-RT version

CODE::
{DynGen.ar(1, \test, realtime: 0.0)}.plot(0.1);
::

RT version

CODE::
{DynGenRT.ar(1, \test, realtime: 1.0)}.plot(0.1);
::
::
argument:: ... args
No excessive positional arguments will be captured, this argument is only necessary to capture arbitrary keyword arguments.

argument:: kwargs
Each keyword argument that is not matched prior will be looked up if it matches the parameter variables of a script, which are variables which are prefixed with a CODE::_:: within DynGen code.
The keyword argument is written without this prefix.

EXAMPLES::

A phase modulatable version of LINK::Classes/SinOscFB::.

CODE::
(
~sinOscFB = DynGenDef(\sinOscFB, "
phase += 0;
y1 += 0;
twoPi = 2*$pi;
inc += 0;

inc = twoPi * _freq / srate;

x = phase + (_fb * y1) + _phaseMod;

phase += inc;
// wrap phase
phase -= (phase >= twoPi) * twoPi;

out0 = sin(x);

y1 = out0;
").send;
)::

CODE::
(
Ndef(\x, {
	var sig = DynGen.ar(1, ~sinOscFB, params: [
		freq: \freq.ar(100.0),
		fb: \fb.ar(0.6, spec: [0.0, pi]),
		phaseMod: SinOsc.ar(\phaseModFreq.ar(1000.0 * pi)) * \modAmt.ar(0.0, spec:[0.0, 1000.0]),
	]);
	sig * 0.1;
}).play.gui;
)
::

Delay line

CODE::
(
~delayLine = DynGenDef(\delayLine, "
buf[_writePos] = in0;
out0 = buf[_readPos];
").send;
)
::

CODE::
(
Ndef(\delay, {
	var bufSize = SinOsc.ar(4.2).range(1000, 2000);
	var writePos = LFSaw.ar(2.0, 0.02).range(1, bufSize);
	var readPos = LFSaw.ar(pi, 0.0).range(1, bufSize);
	var sig = DynGen.ar(1, ~delayLine,
		SinOsc.ar(100.0),
		params: [
			writePos: writePos.floor,
			readPos: readPos.floor,
		],
	);
	sig.dup * 0.1;
}).play;
)
::

Two cross phase-modulated sine oscillators, 64 times oversampled.

CODE::
(
~complex = DynGenDef(\complex, "
twopi = 2*$pi;

phaseA += 0;
phaseB += 0;

oversample = 64;

osSrate = srate * oversample;
incA = _freqA / osSrate;
incB = _freqB / osSrate;

sumA = 0;
sumB = 0;

// calculate subsaples
loop(oversample,
    phaseA += incA;
    phaseB += incB;
    // wrap phases between [0, 1)
    phaseA -= floor(phaseA);
    phaseB -= floor(phaseB);

    // apply cross-phase modulation
    phaseA = phaseA + _modIndexA * sin(twopi * phaseB);
    phaseB = phaseB + _modIndexB * sin(twopi * phaseA);

    // accumulate (for downsampling)
    sumA += sin(twopi * phaseA);
    sumB += sin(twopi * phaseB);
);

// scale down b/c of os
out0 = sumA / oversample;
out1 = sumB / oversample;
").send;
)
::

CODE::
(
Ndef(\y, {
	var sig = DynGen.ar(2, ~complex, params: [
		freqA: \freqA.ar(200.0),
		freqB: \freqB.ar(pi*100),
		modIndexA: \modA.ar(0.02, spec: [-0.1, 0.1]) * 0.05 * Env.perc(releaseTime: \releaseTime.kr(0.2)).ar(gate: Impulse.ar(\offsetKick.kr(4.0))),
		modIndexB: \modB.ar(0.0, spec: [-0.1, 0.1]) * 0.05,
	]);
	sig * 0.1;
}).play.gui;
)
::
